<!doctype html>
<html lang="en-US">
  <head>
    <link href="/assets/index.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
      /* TODO: [P*] Can we eliminate this style? */
      .fui-FluentProvider,
      .webchat-fluent {
        height: 100%;
      }
    </style>
  </head>
  <body>
    <main id="webchat"></main>
    <script type="importmap">
      {
        "imports": {
          "@fluentui/react-components": "https://esm.sh/@fluentui/react-components?deps=react@18.3.1,react-dom@18.3.1&exports=FluentProvider,createDarkTheme,webLightTheme",
          "botframework-webchat": "/__dist__/packages/bundle/static/botframework-webchat.js",
          "botframework-webchat/component": "/__dist__/packages/bundle/static/botframework-webchat/component.js",
          "botframework-webchat/decorator": "/__dist__/packages/bundle/static/botframework-webchat/decorator.js",
          "botframework-webchat/hook": "/__dist__/packages/bundle/static/botframework-webchat/hook.js",
          "botframework-webchat/internal": "/__dist__/packages/bundle/static/botframework-webchat/internal.js",
          "botframework-webchat-core": "/__dist__/packages/bundle/static/botframework-webchat-core.js",
          "botframework-webchat-fluent-theme": "/__dist__/packages/fluent-theme/static/botframework-webchat-fluent-theme.js",
          "jest-mock": "https://esm.sh/jest-mock",
          "react": "/__dist__/packages/bundle/static/react.js",
          "react-dom": "/__dist__/packages/bundle/static/react-dom.js",
          "react-dom/client": "/__dist__/packages/bundle/static/react-dom/client.js",
          "https://esm.sh/react@18.3.1/es2022/react.mjs": "/__dist__/packages/bundle/static/react.js",
          "https://esm.sh/react@18.3.1/es2022/react-dom.mjs": "/__dist__/packages/bundle/static/react-dom.18.js",
          "https://esm.sh/react@18.3.1/es2022/react-dom/client.mjs": "/__dist__/packages/bundle/static/react-dom.18/client.js"
        }
      }
    </script>
    <script type="module">
      import '/test-harness.mjs';
      import '/test-page-object.mjs';
      import { FluentProvider, webLightTheme } from '@fluentui/react-components';
      import { createDirectLine, createStoreWithOptions, hooks, ReactWebChat } from 'botframework-webchat';
      import { getActivityLivestreamingMetadata } from 'botframework-webchat-core';
      import { FluentThemeProvider } from 'botframework-webchat-fluent-theme';
      import { fn, spyOn } from 'jest-mock';
      import { createElement } from 'react';
      import { createRoot } from 'react-dom/client';

      const error = console.error.bind(console);
      const IGNORING_KEYWORDS = [
        'Cannot update a component',
        'Support for defaultProps',
        'ReactDOM.render is no longer supported',
        'To locate the bad setState()',
        'has been deprecated, use `import {'
      ];

      spyOn(console, 'error').mockImplementation((...args) => {
        const [message] = args;

        if (typeof message === 'string' && IGNORING_KEYWORDS.some(keywords => message.includes(keywords))) {
          return;
        }

        error(...args);
      });

      function removeInline(array, ...items) {
        items.forEach(item => {
          let index;

          while (~(index = array.indexOf(item))) {
            array.splice(index, 1);
          }
        });
      }

      run(async function () {
        const {
          testHelpers: { createDirectLineEmulator }
        } = window;

        // TODO: This is for `createDirectLineEmulator` only, should find ways to eliminate this line.
        window.WebChat = { createStoreWithOptions };

        const { directLine, store } = createDirectLineEmulator();

        // renderWebChat({ directLine, store }, document.getElementById('webchat'));

        const fluentTheme = {
          ...webLightTheme,
          // Original is #242424 which is too light for fui-FluentProvider to pass our accessibility checks.
          colorNeutralForeground1: '#1b1b1b'
        };

        createRoot(document.getElementsByTagName('main')[0]).render(
          createElement(
            FluentProvider,
            { className: 'fui-FluentProvider', theme: fluentTheme },
            createElement(
              FluentThemeProvider,
              { variant: 'fluent' },
              createElement(ReactWebChat, { directLine, store })
            )
          )
        );

        await pageConditions.uiConnected();

        const res = await fetch('./transcript.json');
        const json = await res.json();
        const livestreams = new Map();

        for (const activity of json) {
          if (activity.type === 'typing' && activity.channelData?.chunkType === 'delta') {
            const sequence = activity.channelData.streamSequence;
            const id = sequence === 1 ? activity.id : activity.channelData.streamId;

            if (!id) {
              continue;
            }

            const impartials = livestreams.get(id) || [];

            impartials[sequence - 1] = activity.text;

            livestreams.set(id, impartials);
          }
        }

        for (const activity of json) {
          if (activity.type === 'typing' && activity.channelData?.chunkType === 'delta') {
            const sequence = activity.channelData.streamSequence;
            const id = sequence === 1 ? activity.id : activity.channelData.streamId;

            if (!id) {
              continue;
            }

            const impartials = livestreams.get(id) || [];

            activity.text = impartials.slice(0, sequence - 1).join('');
          }
        }

        for (const activity of json) {
          // Fix timestamp due to a bug in DtE.
          activity.timestamp = activity.timestamp ? decodeURIComponent(activity.timestamp) : undefined;
        }

        const thoughtIdSet = new Set();

        for (let activity of json) {
          const livestreamingMetadata = getActivityLivestreamingMetadata(activity);

          // const chainId = `chain:${livestreamingMetadata?.sessionId}`;
          const {
            streamId: _streamId,
            streamSequence: _streamSequence,
            streamType: _streamType,
            restChannelData
          } = activity.channelData || {};
          const thoughts = activity.entities?.filter(({ type }) => type === 'thought') ?? [];

          for (const thought of thoughts) {
            const chainId = `chain-${thought.chainOfThoughtId}`;
            const thoughtId = `${chainId}:thought-${thought.sequenceNumber}`;
            const thoughtPosition = thought.sequenceNumber;

            const channelData = { ...restChannelData };

            if (livestreamingMetadata.type === 'final activity') {
              console.log('END', { chainId, thoughtId });

              channelData.streamId = thoughtId;
              channelData.streamType = 'final';

              thoughtIdSet.delete(thoughtId);
            } else if (thoughtIdSet.has(thoughtId)) {
              channelData.streamId = thoughtId;
              channelData.streamSequence = livestreamingMetadata.sequenceNumber;
              channelData.streamType = 'streaming';
            } else {
              console.log('START', { chainId, thoughtId });

              channelData.streamSequence = 1;
              channelData.streamType = 'streaming';

              thoughtIdSet.add(thoughtId);
            }

            await directLine.emulateIncomingActivity(
              {
                channelData,
                entities: [
                  {
                    '@context': 'https://schema.org',
                    '@id': '',
                    '@type': 'Message',
                    type: 'https://schema.org/Message',

                    abstract: thought.title,
                    creativeWorkStatus: thought.status === 'incomplete' ? 'incomplete' : 'published',
                    isPartOf: { '@id': chainId, '@type': 'HowTo' },
                    keywords: ['AIGeneratedContent'],
                    position: thought.sequenceNumber
                  }
                ],
                id: channelData.streamSequence === 1 ? thoughtId : `${thoughtId}:${activity.id}`,
                text: thought.text,
                timestamp: activity.timestamp || new Date().toISOString(),
                type: activity.type
              },
              { skipWait: true }
            );

            removeInline(activity.entities, thought);
          }

          if (!thoughts.length || livestreamingMetadata?.type === 'final activity') {
            await directLine.emulateIncomingActivity(activity, { skipWait: true });
          }

          await new Promise(resolve => setTimeout(resolve, 0));
        }

        console.error.mockRestore();
      });
    </script>
  </body>
</html>
