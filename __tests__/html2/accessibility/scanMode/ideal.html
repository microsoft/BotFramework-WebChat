<!doctype html>
<html lang="en-US">
  <head>
    <link href="/assets/index.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
      /* .chat-history:focus {
        background-color: Yellow;
      } */

      .chat-history {
        padding: 4px;
      }

      .chat-message__is-active {
        outline: dashed 2px black;
      }
    </style>
  </head>
  <body>
    <main></main>
    <script type="importmap">
      {
        "imports": {
          "classnames": "https://esm.sh/classnames",
          "jest-mock": "https://esm.sh/jest-mock",
          "react": "https://esm.sh/react",
          "react-dom": "https://esm.sh/react-dom"
        }
      }
    </script>
    <script crossorigin="anonymous" src="https://esm.sh/tsx" type="module"></script>
    <script type="text/babel">
      import cx from 'classnames';
      import { useRefFrom } from 'https://esm.sh/use-ref-from';
      import { useStateWithRef } from 'https://esm.sh/use-state-with-ref';
      import { forwardRef, useCallback, useEffect, useMemo, useRef, useState } from 'react';
      import { createRoot } from 'react-dom/client';

      function usePrevious(value) {
        const previousRef = useRef();

        useEffect(() => {
          previousRef.current = value;
        });

        return previousRef.current;
      }

      function ChatMessage({ abstract, activeMode, children, index, onLeave }) {
        const bodyRef = useRef();
        const bodyId = useMemo(() => crypto.randomUUID(), []);
        const contentId = useMemo(() => crypto.randomUUID(), []);
        const headerId = useMemo(() => crypto.randomUUID(), []);
        const onLeaveRef = useRefFrom(onLeave);

        const isFocused = activeMode === 'focus';
        const wasFocused = usePrevious(isFocused);
        const becomingFocused = !wasFocused && isFocused;

        const isFocusedRef = useRefFrom(isFocused);

        const handleKeyDown = useCallback(
          event => {
            if (isFocusedRef.current) {
              event.stopPropagation();
            }

            if (event.key === 'Escape') {
              event.stopPropagation();

              onLeaveRef.current?.();
            }
          },
          [onLeaveRef]
        );

        useEffect(() => {
          if (becomingFocused) {
            bodyRef.current?.focus();
          }
        }, [becomingFocused]);

        return (
          <article
            aria-labelledby={headerId}
            className={cx('chat-message', { 'chat-message__is-active': activeMode === 'active' })}
            id={`chat-message__index-${index}`}
          >
            <h4 className="chat-message__header" id={headerId}>
              {abstract}
            </h4>
            <div
              aria-labelledby={contentId} // Narrator: without aria-labelledby, after pressing ENTER and focus on this element, Narrator will say nothing.
              className="chat-message__body"
              id={bodyId}
              inert={!isFocused}
              onKeyDown={handleKeyDown}
              ref={bodyRef}
              role={isFocused ? 'document' : undefined} // As instructed by C+AI accessibility team: after pressing ENTER, add role="document" and focus on the element, screen reader should change to scan/browse mode.
              tabindex={isFocused ? -1 : undefined} // As instructed by C+AI accessibility team: after pressing ENTER, add role="document" and focus on the element, screen reader should change to scan/browse mode.
            >
              <div className="chat-message__content" id={contentId} role="none">
                {children}
              </div>
            </div>
          </article>
        );
      }

      function ChatHistory({ onLeave }) {
        const [activeMessageIndex, setActiveMessageIndex] = useState(0);
        const [isFocused, setIsFocused, isFocusedRef] = useStateWithRef(false);
        const onLeaveRef = useRefFrom(onLeave);
        const rootRef = useRef();

        const handleKeyDown = useCallback(
          event => {
            if (event.key === 'ArrowUp') {
              event.stopPropagation();

              setActiveMessageIndex(index => Math.max(0, index - 1));
            } else if (event.key === 'ArrowDown') {
              event.stopPropagation();

              setActiveMessageIndex(index => Math.min(1, index + 1));
            } else if (event.key === 'Enter') {
              event.stopPropagation();

              setIsFocused(true);
            } else if (event.key === 'Escape') {
              onLeaveRef.current?.();
            }
          },
          [isFocusedRef, onLeaveRef, setActiveMessageIndex, setIsFocused]
        );

        const handleMessageLeave = useCallback(() => {
          rootRef.current?.focus();
          setIsFocused(false);
        }, [rootRef, setIsFocused]);

        return (
          <div
            aria-activedescendant={`chat-message__index-${activeMessageIndex}`} // Matter of taste: we are using active descendant to control focus, instead of roving tab index.
            className="chat-history"
            onKeyDown={handleKeyDown}
            ref={rootRef}
            role="group" // Required: aria-activedescendant is only available for role="group".
            tabindex="0" // Required: container of the active descendant must be focusable.
          >
            <div
              className="chat-history__body"
              role="feed" // Required: we are using role="feed/article" to represent the chat thread.
            >
              <ChatMessage
                abstract="Bot said: Hello, World!" // Matter of taste: this is for screen reader user pressing H key to quickly jump between messages.
                activeMode={activeMessageIndex === 0 ? (isFocused ? 'focus' : 'active') : undefined}
                index={0}
                onLeave={activeMessageIndex === 0 ? handleMessageLeave : undefined}
              >
                <p>Hello, World!</p>
                <p>
                  Click <a href="https://bing.com/">this link</a> for more details.
                </p>
              </ChatMessage>
              <ChatMessage
                abstract="You said: Aloha!"
                activeMode={activeMessageIndex === 1 ? (isFocused ? 'focus' : 'active') : undefined}
                index={1}
                onLeave={activeMessageIndex === 1 ? handleMessageLeave : undefined}
              >
                <p>Aloha!</p>
              </ChatMessage>
            </div>
          </div>
        );
      }

      const SendBox = forwardRef(function SendBox(_, ref) {
        const handleSubmit = useCallback(event => {
          event.preventDefault();
        }, []);

        return (
          <form onSubmit={handleSubmit}>
            <textarea placeholder="Type a message" ref={ref} />
          </form>
        );
      });

      function ChatApp() {
        const sendBoxRef = useRef();

        const handleChatHistoryLeave = useCallback(() => {
          sendBoxRef.current?.focus();
        }, [sendBoxRef]);

        return (
          <div
            className="chat-app"
            role="application" // Required: role="document" will only work when its container has role="application".
          >
            <ChatHistory onLeave={handleChatHistoryLeave} />
            <SendBox ref={sendBoxRef} />
          </div>
        );
      }

      const mainElement = document.querySelector('main');

      mainElement && createRoot(mainElement).render(<ChatApp />);

      setTimeout(() => {
        // document.querySelector('[role="feed"]')?.focus();
        document.querySelector('textarea')?.focus();
      }, 100);
    </script>
  </body>
</html>
